**Peng Simulation Chapter Notes**

#### Simulations can be used for:
Random number generation
Random sampling
Simulate a system to model random output

**Stanford Simulation Chapter Notes:**

**Miami Simulation Chapter Notes:**
The if function:
Take a certain action based on the outcome of an event
Looking at conditional statements
Logical data in binary
if statement:
A program unit that is a conditional statement
Selection of action from multiple possibilities using different lines
Conditional statements usually reside inside a function
Express alternative behavior depending on argument values
A conditional statement begins with an if header followed by a condition to examine in parentheses
After the condition, there's an action to perform enclosed in curly braces
If the condition is true, the program executes the statements inside the braces, making it an if statement
If a conditional statement contains a return statement, and it executes, the rest of the code in the function is skipped
General description of if statement:
RCopy code
if (<expression>) { <body> } else if (<expression>) { <body> } else if (<expression>) { <body> ... } else { <body> } 
The else means "otherwise"
We can stack up else if blocks after an initial if to define a series of alternative options
An if-block cannot begin with an else in the series
There must exist one if clause
When a series of else if blocks appear after an if, this represents a series of alternatives, called an if sequence
An if without a preceding else begins a new if sequence
R scans all the conditions in an if sequence and takes action when it finds a condition that evaluates to TRUE. All other actions before and after the matching one are ignored
The else block is optional and takes care of everything that does not have a match
Comparing strings:

**Parker Simulation Chapter:**
Simulating a sample from common probability distributions
Simulation experiments for sampling distributions
Simulation experiments for type I error rates and power calculations
For more complex applications of simulation, they will provide (though not cover in class):
Simulating from non-standard distributions (Accept-Reject and MCMC)
Simulation experiment from an SIR epidemic model
Sampling from complex distributions:
There are numerous techniques to sample from complex probability distributions
Some of these techniques are specifically employed to generate samples from the 'r' functions demonstrated in the preceding section
Two fundamental techniques are the accept-reject algorithm and the Metropolis-Hastings Markov Chain Monte Carlo (MCMC) algorithm
Learning the Accept-Reject Algorithm: It generates random samples from a probability distribution using a proposal sample from an easy-to-sample "envelope" distribution. It involves deciding whether to accept or reject the generated proposal sample.
A simple example to illustrate this method considers a continuous random variable X, concentrated on the interval (0, 2). Points P1, P2, ..., are uniformly and randomly sprinkled under the density function of X. The random points Pt are represented as two-dimensional random variables (Xi, Yi), where Xi and Yi are the random coordinates of the ith point.


-	Getting random points by simulating an envelope region
-	we can’t simulate directly from fX, 
-	simulate from another “envelope” distribution with density h that we can simulate from.
-	 example 
-	 h=0.5,0<x<2, 
-	the density of the uniform distribution on (0,2)
-	let k be such that kh≥fX 
-	let  Y∼U(0,kh(X))
-	given X, then (X,Y) will be uniformly distributed over the region defined by the area below the curve kh. 
-	 example : k=2
-	 only want the points under the true density, so we accept X values if Y<fX(X) and reject them otherwise.


